/*
 *
 *  unicode.c – functions related to the Unicode® Standard
 *
 *
 *  created by: Damien Lejay
 *
 *
 *  Sections you will find in this file:
 *
 *	§ Unicode® Core Specification
 *	§ Unicode® Standard Annex #11 – EAST ASIAN WIDTH
 *	§ Unicode® Standard Annex #29 – UNICODE TEXT SEGMENTATION
 *
 *  Data tables are generated by tables/generate_unicode_tables.py
 */

#include "unicode.h"
#include <stddef.h>

/*
 * =================================================================
 *
 *		    Unicode® 16.0.0 Core Specification
 *
 * =================================================================
 */

struct interval
{
    rune_T first;
    rune_T last;
};

/*
 * Return true if "r" is in "table[size / sizeof(struct interval)]".
 */
static bool
in_table(struct interval *table, size_t size, rune_T r)
{
    size_t mid = 0, bot = 0, top = 0;

    // first quick check for Latin1 etc. characters
    if (r < table[0].first)
	return false;

    // binary search in table
    bot = 0;
    top = size / sizeof(struct interval) - 1;
    while (top >= bot)
    {
	mid = (bot + top) / 2;
	if (table[mid].last < r)
	    bot = mid + 1;
	else if (table[mid].first > r)
	    top = mid - 1;
	else
	    return true;
    }
    return false;
}

/*
 * -----------------------------------------------------------------
 *  2.1 Combining characters
 * -----------------------------------------------------------------
 */

/*
 * Source: UnicodeData.txt
 */
bool
unicode_is_combining(rune_T r)
{
    struct interval combining[] = {
	#include "tables/unicode_combining.inc"
    };

    return in_table(combining, sizeof(combining), r);
}

/* -----------------------------------------------------------------
 *  3.13 Default Case Algorithms
 * ----------------------------------------------------------------- */

/* Tailoring.
 *
 * The default casing operations are intended for use in the absence of
 * tailoring for particular languages and environments. Where a particular
 * environment requires tailoring of casing operations to produce correct
 * results, use of such tailoring does not violate conformance to the standard.
 */

struct convert_interval
{
    rune_T range_start;
    rune_T range_end;
    short int step;
    rune_T offset;
};

/*
 * Generic conversion function for case operations.
 * Uses binary search on a conversion "table".
 */
static rune_T
unicode_convert(rune_T r, struct convert_interval table[], size_t table_size)
{
    size_t start, mid, end; // indices into table
    size_t entries = table_size / sizeof(struct convert_interval);

    start = 0;
    end = entries;
    while (start < end)
    {
	// need to search further
	mid = (end + start) / 2;
	if (table[mid].range_end < r)
	    start = mid + 1;
	else
	    end = mid;
    }
    if (start < entries
	    && table[start].range_start <= r
	    && r <= table[start].range_end
	    && (r - table[start].range_start) % table[start].step == 0)
	return (r + table[start].offset);
    else
	return r;
}

/*  --- 13.2 Default Case Conversion ---  */

/*
 * Simple toupper and tolower, based on UnicodeData.txt
 */
rune_T
unicode_simple_toupper(rune_T r)
{
    struct convert_interval simple_toupper[] = {
	#include "tables/unicode_simple_toupper.inc"
    };

    /* Be quick for ASCII */
    if ('a' <= r && r <= 'z')
        return r - ('a' - 'A');

    return unicode_convert(r, simple_toupper, sizeof(simple_toupper));
}

rune_T
unicode_simple_tolower(rune_T r)
{
    struct convert_interval simple_tolower[] = {
	#include "tables/unicode_simple_tolower.inc"
    };

    /* Be quick for ASCII */
    if ('A' <= r && r <= 'Z')
        return r - ('A' - 'a');

    return unicode_convert(r, simple_tolower, sizeof(simple_tolower));
}

/*  --- 3.13.3 Default Case Folding ---  */

/*
 * Simple Case Folding, based on CaseFolding-16.0.0.txt
 * using mappings with status C + S.
 */
rune_T
unicode_simple_fold(rune_T r)
{
    struct convert_interval simple_fold[] = {
	#include "tables/unicode_simple_fold.inc"
    };

    if (r < 0x80)
	// be fast for ASCII
	return r >= 0x41 && r <= 0x5a ? r + 32 : r;
    return unicode_convert(r, simple_fold, sizeof(simple_fold));
}

/*
 * =================================================================
 *
 *		    Unicode® 16.0.0 Standard Annex #11
 *
 *			EAST ASIAN WIDTH
 *
 * =================================================================
 */
bool
unicode_is_eastasian_ambiguous(rune_T r)
{
    struct interval eastasian_ambiguous[] = {
	#include "tables/unicode_eastasian_ambiguous.inc"
    };

    return in_table(eastasian_ambiguous, sizeof(eastasian_ambiguous), r);
}

/*
 * =================================================================
 *
 *		    Unicode® 16.0.0 Standard Annex #29
 *
 *	    U N I C O D E  T E X T  S E G M E N T A T I O N
 *
 * =================================================================
 */

/*
 * =================================================================
 *
 *  4 Word Boundaries
 *
 * =================================================================
 */

struct wb_interval
{
    rune_T first;
    rune_T last;
    unicode_word_break_T wb;
};

/*
 *  Source: word_break-16.0.0.txt
 */
unicode_word_break_T
unicode_get_word_break_property(rune_T r)
{
    struct wb_interval word_break[] = {
	#include "tables/unicode_word_break.inc"
    };
    size_t bot = 0, top = 0, mid = 0;

    // Defensive check
    if (r < 0 || r > 0x10ffff)
	return U_WB_Other;

    // binary search in table
    top = sizeof(word_break) / sizeof(struct wb_interval) - 1;
    while (top >= bot)
    {
	mid = (bot + top) / 2;
	if (word_break[mid].last < r)
	    bot = mid + 1;
	else if (word_break[mid].first > r)
	    top = mid - 1;
	else
	    return word_break[mid].wb;
    }
    return U_WB_Other;
}

bool
unicode_is_w_seg_space(rune_T c)
{
    return c == 0x0020 ||  // SPACE
	   c == 0x1680 ||  // OGHAM SPACE MARK
	   (c >= 0x2000 && c <= 0x200A) ||  // EN QUAD .. HAIR SPACE
	   c == 0x205F ||  // MEDIUM MATHEMATICAL SPACE
	   c == 0x3000;    // IDEOGRAPHIC SPACE
}
