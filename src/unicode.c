/* vi:set ts=8 sts=4 sw=4 et:
 *
 *  unicode.c – functions related to the Unicode® Standard
 *
 *  Sections in this file:
 *    § Unicode® Core Specification
 *    § Unicode® Standard Annex #11 – EAST ASIAN WIDTH
 *    § Unicode® Standard Annex #29 – UNICODE TEXT SEGMENTATION
 *
 *  Data tables are generated by tables/generate_unicode_tables.py
 */

#include "unicode.h"
#include <stddef.h>
#include <stdlib.h>

/*----------------------------------------------------------------------*/
/* Type definitions for data tables                                     */
/*----------------------------------------------------------------------*/

/* Interval of codepoints [first..last] */
struct interval {
    rune_T first;
    rune_T last;
};

/* Case-mapping interval: [first..last] with step and offset */
struct convert_interval {
    rune_T first;
    rune_T last;
    short  step;
    rune_T offset;
};

/* East Asian Width interval with property */
struct eaw_interval {
    rune_T first;
    rune_T last;
    unicode_east_asian_width_T eaw;
};

/* Word-break interval with property */
struct wb_interval {
    rune_T first;
    rune_T last;
    unicode_word_break_T wb;
};

/*----------------------------------------------------------------------*/
/* Data table definitions                                               */
/*----------------------------------------------------------------------*/

static const struct interval combining[] = {
#include "tables/unicode_combining.inc"
};

static const struct convert_interval simple_toupper[] = {
#include "tables/unicode_simple_toupper.inc"
};

static const struct convert_interval simple_tolower[] = {
#include "tables/unicode_simple_tolower.inc"
};

static const struct convert_interval simple_fold[] = {
#include "tables/unicode_simple_fold.inc"
};

static const struct eaw_interval east_asian_width[] = {
#include "tables/unicode_east_asian_width.inc"
};

static const struct wb_interval word_break[] = {
#include "tables/unicode_word_break.inc"
};

/*----------------------------------------------------------------------*/
/* Generic comparator for binary search across all table types          */
/*----------------------------------------------------------------------*/

/* Compare rune 'r' against [first..last] fields of any table element */
static int
range_cmp(const void *key, const void *elem)
{
    rune_T r = *(const rune_T *)key;
    const struct interval *iv = elem;

    if (r < iv->first)
        return -1;
    if (r > iv->last )
        return +1;
    return 0;
}

/*----------------------------------------------------------------------*/
/* Unicode® 16.0.0 Core Specification                                  */
/*----------------------------------------------------------------------*/

/* Return true if r falls in any [first..last] in table */
static bool
in_table(rune_T r, const struct interval *table, size_t count)
{
    return bsearch(&r, table, count, sizeof *table, range_cmp) != NULL;
}

/* Test for combining character property */
bool
unicode_is_combining(rune_T r)
{
    return in_table(r, combining, sizeof(combining) / sizeof *combining);
}

/*----------------------------------------------------------------------*/
/* 3.13 Default Case Algorithms                                        */
/*----------------------------------------------------------------------*/

/* Lookup in convert table and apply offset if valid */
static rune_T
convert(rune_T r, const struct convert_interval table[], size_t count)
{
    const struct convert_interval *iv;

    iv = bsearch(&r, table, count, sizeof *table, range_cmp);
    if (iv && ((r - iv->first) % iv->step) == 0)
        return r + iv->offset;
    return r;
}

/* Simple uppercase: ASCII fast path + table lookup */
rune_T
unicode_simple_toupper(rune_T r)
{
    if ('a' <= r && r <= 'z')
        return r - ('a' - 'A');
    return convert(r, simple_toupper,
                   sizeof(simple_toupper) / sizeof *simple_toupper);
}

/* Simple lowercase: ASCII fast path + table lookup */
rune_T
unicode_simple_tolower(rune_T r)
{
    if ('A' <= r && r <= 'Z')
        return r - ('A' - 'a');
    return convert(r, simple_tolower,
                   sizeof(simple_tolower) / sizeof *simple_tolower);
}

/* Simple case fold: ASCII fast path + table lookup */
rune_T
unicode_simple_fold(rune_T r)
{
    if (r < 0x80)
        return ('A' <= r && r <= 'Z') ? r + 32 : r;
    return convert(r, simple_fold,
                   sizeof(simple_fold) / sizeof *simple_fold);
}

/*----------------------------------------------------------------------*/
/* Unicode® 16.0.0 Annex #11 – East Asian Width                         */
/*----------------------------------------------------------------------*/

/* Return East Asian Width property for r */
unicode_east_asian_width_T
unicode_east_asian_width(rune_T r)
{
    const struct eaw_interval *iv;

    iv = bsearch(&r,
                 east_asian_width,
                 sizeof(east_asian_width) / sizeof *east_asian_width,
                 sizeof *east_asian_width,
                 range_cmp);
    if (iv == NULL)
        return U_EAW_N;
    return iv->eaw;
}

/*----------------------------------------------------------------------*/
/* Unicode® 16.0.0 Annex #29 – Text Segmentation                        */
/*----------------------------------------------------------------------*/

/* Return Word Break property for r */
unicode_word_break_T
unicode_word_break(rune_T r)
{
    const struct wb_interval *iv;

    iv = bsearch(&r,
                 word_break,
                 sizeof(word_break) / sizeof *word_break,
                 sizeof *word_break,
                 range_cmp);
    if (iv == NULL)
        return U_WB_Other;
    return iv->wb;
}

/* Identify characters that act as word-segmenting spaces */
bool
unicode_is_w_seg_space(rune_T c)
{
    return c == 0x0020 || c == 0x1680 || (c >= 0x2000 && c <= 0x200A) ||
           c == 0x205F || c == 0x3000;
}
