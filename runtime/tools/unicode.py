
#!/usr/bin/env python3
import urllib.request
import tempfile
import unicodedata
import subprocess
import os

# URL to the Unicode Word Break Property file (editable)
URL_PATH = 'https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/WordBreakProperty.txt'


def download_file(url):
    """Download content from URL and return it as a list of lines."""
    with urllib.request.urlopen(url) as response:
        data = response.read().decode('utf-8').splitlines()
    return data


def parse_wordbreak(lines):
    intervals = []
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        # remove inline comments and split
        parts = line.split('#', 1)[0].split(';')
        code_range = parts[0].strip()
        prop = parts[1].strip()
        if '..' in code_range:
            start_str, end_str = code_range.split('..')
        else:
            start_str = end_str = code_range
        start = int(start_str, 16)
        end = int(end_str, 16)
        intervals.append((start, end, f"U_WB_{prop}"))
    return intervals


def merge_intervals(intervals):
    intervals = sorted(intervals, key=lambda x: x[0])
    merged = []
    for start, end, prop in intervals:
        if merged and prop == merged[-1][2] and start <= merged[-1][1] + 1:
            merged[-1] = (merged[-1][0], max(merged[-1][1], end), prop)
        else:
            merged.append((start, end, prop))
    return merged


def fill_gaps(intervals, max_code=0x10FFFF):
    filled = []
    prev_end = -1
    for start, end, prop in intervals:
        if start > prev_end + 1:
            filled.append((prev_end + 1, start - 1, 'U_WB_Other'))
        filled.append((start, end, prop))
        prev_end = end
    if prev_end < max_code:
        filled.append((prev_end + 1, max_code, 'U_WB_Other'))
    return filled


def format_comment(start, end, prop):
    # Skip WB_Other and unnamed codepoints
    if prop == 'U_WB_Other':
        return ''
    try:
        name_start = unicodedata.name(chr(start))
    except ValueError:
        return ''
    if start == end:
        return name_start
    try:
        name_end = unicodedata.name(chr(end))
    except ValueError:
        return ''
    return f"{name_start}..{name_end}"


def generate_c_table(intervals):
    # Prepare entries and comments
    entries = []
    for start, end, prop in intervals:
        entry = f"    {{0x{start:X}, 0x{end:X}, {prop}}},"
        comment = format_comment(start, end, prop)
        entries.append((entry, comment))

    # Compute padding width for alignment
    max_len = max(len(entry) for entry, _ in entries)

    lines = ['// Autoâ€generated by unicode.py from WordBreakProperty.txt; do not edit']
    for entry, comment in entries:
        if comment:
            pad = ' ' * (max_len - len(entry) + 1)
            lines.append(f"{entry}{pad}// {comment}")
        else:
            lines.append(entry)
    return '\n'.join(lines)


def main():
    # Download and parse
    lines = download_file(URL_PATH)
    intervals = parse_wordbreak(lines)
    merged = merge_intervals(intervals)
    filled = fill_gaps(merged)
    final = merge_intervals(filled)

    # Write out a .inc file for inclusion in unicode.c
    outname = os.path.join(os.getcwd(), 'unicode_word_break.inc')
    with open(outname, 'w', encoding='utf-8') as out:
        out.write(generate_c_table(final))
    print(f"Wrote initializer list to {outname}")


if __name__ == '__main__':
    main()

